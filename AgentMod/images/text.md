请你设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。

你需要实现 LRUCache 类：

LRUCache(int capacity): 以正整数作为容量 capacity 初始化 LRU 缓存。
int get(int key): 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1。
void put(int key, int value): 如果关键字 key 已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。
进阶要求：你可以否实现 get 和 put 操作的时间复杂度均为 O(1)？

2. 示例
输入：

JSON
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
执行过程解析：

LRUCache(2): 初始化容量为 2 的缓存 {}
put(1, 1): 缓存是 {1: 1}
put(2, 2): 缓存是 {1: 1, 2: 2}
get(1): 返回 1 (此时 1 变为最近使用)，缓存逻辑顺序 [1, 2]
put(3, 3): 容量已满，删除最近最少使用的 2。缓存变为 {1: 1, 3: 3}，逻辑顺序 [1, 3]
get(2): 返回 -1 (2 已被删除)
put(4, 4): 容量已满，删除最近最少使用的 1。缓存变为 {3: 3, 4: 4}，逻辑顺序 [3, 4]
get(1): 返回 -1 (1 已被删除)
get(3): 返回 3 (3 变为最近使用)，逻辑顺序 [3, 4]
get(4): 返回 4 (4 变为最近使用)，逻辑顺序 [3, 4] -> [3, 4] (4 刚用过)
输出：

JSON
[null, null, null, 1, null, -1, null, -1, 3, 4]
